import 'package:flutter/widgets.dart';
import 'package:unping_ui/unping_ui.dart';

/// Predefined input configurations matching common design patterns.
class Inputs {
  /// Standard single-line text input.
  static BaseInput text({
    String? label,
    String? placeholder,
    IconData? prefixIcon,
    IconData? suffixIcon,
    String? tooltipMessage,
    String? helperText,
    String? errorText,
    TextEditingController? controller,
    FocusNode? focusNode,
    ValueChanged<String>? onChanged,
    ValueChanged<String>? onSubmitted,
    bool enabled = true,
    bool readOnly = false,
    InputSize size = InputSize.md,
    Color? iconColor,
    double? iconSize,
    Widget? prefix,
    Widget? suffix,
    Iterable<String>? autofillHints,
    TextInputType? keyboardType,
    TextInputAction? textInputAction,
    InputState? forceState,
  }) {
    return BaseInput(
      placeholder: placeholder,
      tooltipMessage: tooltipMessage,
      helperText: helperText,
      iconColor: iconColor,
      iconSize: iconSize ?? 18,
      errorText: errorText,
      controller: controller,
      focusNode: focusNode,
      onChanged: onChanged,
      onSubmitted: onSubmitted,
      enabled: enabled,
      size: size,
      prefix: prefix,
      suffix: suffix,
      prefixIcon: prefixIcon,
      suffixIcon: suffixIcon,
      autofillHints: autofillHints,
      keyboardType: keyboardType ?? TextInputType.text,
      forceState: forceState,
      backgroundColor: UiColors.background,
      focusBackgroundColor: UiColors.neutral800,
      borderColor: UiColors.background,
      focusBorderColor: UiColors.background,
      focusRingColor: UiColors.neutral400,
      borderWidth: 1.0,
      borderRadius: UiRadius.sm,
      maxLines: 1,
      minLines: 1,
    );
  }

  /// Multi-line text area input.
  static BaseInput textArea({
    String? label,
    String? placeholder,
    String? tooltipMessage,
    String? helperText,
    String? errorText,
    TextEditingController? controller,
    FocusNode? focusNode,
    ValueChanged<String>? onChanged,
    ValueChanged<String>? onSubmitted,
    bool enabled = true,
    bool readOnly = false,
    InputSize size = InputSize.md,
    int minLines = 3,
    int? maxLines,
    bool resizable = true,
    int? maxLength,
    bool showCharacterCount = true,
    Iterable<String>? autofillHints,
    InputState? forceState,
  }) {
    return BaseInput(
      placeholder: placeholder,
      tooltipMessage: tooltipMessage,
      helperText: helperText,
      errorText: errorText,
      controller: controller,
      focusNode: focusNode,
      onChanged: onChanged,
      onSubmitted: onSubmitted,
      enabled: enabled,
      size: size,
      minLines: minLines,
      maxLines: maxLines ?? 8,
      resizable: resizable,
      maxLength: maxLength,
      showCharacterCount: showCharacterCount,
      autofillHints: autofillHints,
      keyboardType: TextInputType.multiline,
      forceState: forceState,
      backgroundColor: UiColors.background,
      focusBackgroundColor: UiColors.neutral800,
      borderColor: UiColors.background,
      focusBorderColor: UiColors.background,
      focusRingColor: UiColors.neutral400,
      borderWidth: 1.0,
      borderRadius: UiRadius.sm,
    );
  }

  /// Search-optimized input with a leading search icon and a clear button.
  static BaseInput search({
    String? placeholder = 'Search',
    String? tooltipMessage,
    TextEditingController? controller,
    FocusNode? focusNode,
    ValueChanged<String>? onChanged,
    ValueChanged<String>? onSubmitted,
    bool enabled = true,
    InputSize size = InputSize.md,
    InputState? forceState,
  }) {
    return BaseInput(
      placeholder: placeholder,
      tooltipMessage: tooltipMessage,
      controller: controller,
      focusNode: focusNode,
      onChanged: onChanged,
      onSubmitted: onSubmitted,
      enabled: enabled,
      size: size,
      showClearButton: true,
      isSearch: true,
      keyboardType: TextInputType.text,
      forceState: forceState,
      semanticsLabel: 'Search',
      backgroundColor: UiColors.background,
      focusBackgroundColor: UiColors.neutral800,
      borderColor: UiColors.background,
      focusBorderColor: UiColors.background,
      focusRingColor: UiColors.neutral400,
      borderWidth: 1.0,
      borderRadius: UiRadius.sm,
      maxLines: 1,
      minLines: 1,
    );
  }

  /// Password input with show/hide toggle and optional strength indicator.
  static BaseInput password({
    String? label,
    String? placeholder,
    String? tooltipMessage,
    String? helperText,
    String? errorText,
    TextEditingController? controller,
    FocusNode? focusNode,
    ValueChanged<String>? onChanged,
    ValueChanged<String>? onSubmitted,
    bool enabled = true,
    bool readOnly = false,
    InputSize size = InputSize.md,
    bool showStrengthIndicator = true,
    PasswordStrength Function(String value)? strengthCalculator,
    Iterable<String>? autofillHints = const [AutofillHints.password],
    InputState? forceState,
  }) {
    return BaseInput(
      placeholder: placeholder,
      tooltipMessage: tooltipMessage,
      helperText: helperText,
      errorText: errorText,
      controller: controller,
      focusNode: focusNode,
      onChanged: onChanged,
      onSubmitted: onSubmitted,
      enabled: enabled,
      size: size,
      obscureText: true,
      showObscureToggle: true,
      showStrengthIndicator: showStrengthIndicator,
      strengthCalculator: strengthCalculator,
      keyboardType: TextInputType.visiblePassword,
      autofillHints: autofillHints,
      forceState: forceState,
      backgroundColor: UiColors.background,
      focusBackgroundColor: UiColors.neutral800,
      borderColor: UiColors.background,
      focusBorderColor: UiColors.background,
      focusRingColor: UiColors.neutral400,
      borderWidth: 1.0,
      borderRadius: UiRadius.sm,
      maxLines: 1,
      minLines: 1,
    );
  }
}
